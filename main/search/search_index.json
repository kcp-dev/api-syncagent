{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p>The api-syncagent is a Kubernetes agent responsible for integrating external Kubernetes clusters. It runs on a Kubernetes cluster, is configured with credentials to a kcp instance and will then synchronize data out of kcp (i.e. out of kcp workspaces) onto the local cluster, and vice versa.</p>"},{"location":"#high-level-overview","title":"High-level Overview","text":"<p>The intended usecase follows roughly these steps:</p> <ol> <li>A user in kcp with sufficient permissions creates an <code>APIExport</code> object and provides appropriate    credentials for the Sync Agent (e.g. by creating a Kubernetes Secret with a preconfigured kubeconfig    in it).</li> <li>A service owner will now take these credentials and the configured API group (the <code>APIExport</code>'s    name) and use them to setup the Sync Agent. It is assumed that the service owner (i.e. the    cluster-admin in a service cluster) wants to make some resources (usually CRDs) available to use    inside of kcp.</li> <li>The service owner uses the Sync Agent Helm chart (or similar deployment technique) to install the    Sync Agent in their cluster.</li> <li>To actually make resources available in kcp, the service owner now has to create a set of    <code>PublishedResource</code> objects. The configuration happens from their point of view, meaning they    define how to publish a CRD to kcp, defining renaming rules and other projection settings.</li> <li>Once a <code>PublishedResource</code> is created in the service cluster, the Sync Agent will pick it up,    find the referenced CRD, convert/project this CRD into an <code>APIResourceSchema</code> (ARS) for kcp and    then create the ARS in org workspace.</li> <li>Finally the Sync Agent will take all <code>PublishedResources</code> and bundle them into the pre-existing    <code>APIExport</code> in the org workspace. This APIExport can then be bound in the org workspace itself    (or later any workspaces (depending on permissions)) and be used there.</li> <li>kcp automatically provides a virtual workspace for the <code>APIExport</code> and this is what the Sync Agent    then uses to watch all objects for the relevant resources in kcp (i.e. in all workspaces).</li> <li>The Sync Agent will now begin to synchronize objects back and forth between the service cluster    and kcp.</li> </ol>"},{"location":"#details","title":"Details","text":""},{"location":"#data-flow-direction","title":"Data Flow Direction","text":"<p>It might be a bit confusing at first: The <code>PublishedResource</code> CRD describes the world from the standpoint of a service owner, i.e. a person or team that owns a Kubernetes cluster and is tasked with making their CRDs available in kcp (i.e. \"publish\" them).</p> <p>However the actual data flow later will work in the opposite direction: users creating objects inside their kcp workspaces serve as the source of truth. From there they are synced down to the service cluster, which is doing the projection of the <code>PublishedResource</code> in reverse.</p> <p>Of course additional, auxiliary (related) objects could originate on the service cluster. For example if you create a Certificate object in a kcp workspace and it's synced down, cert-manager will then acquire the certificate and create a Kubernetes <code>Secret</code>, which will have to be synced back up (into a kcp workspace, where the certificate originated from). So the source of truth can also be, for auxiliary resources, on the service cluster.</p>"},{"location":"#sync-agent-naming","title":"Sync Agent Naming","text":"<p>Each Sync Agent must have a name, like \"nora\" or \"oskar\". The FQ name for a Sync Agent is <code>&lt;agentname&gt;.&lt;apigroup&gt;</code>, so if the user in kcp had created a new <code>APIExport</code> named <code>databases.examplecorp</code>, the name of the Sync Agent that serves this Service (sic) could be <code>nora.databases.examplecorp</code>.</p>"},{"location":"#uniqueness","title":"Uniqueness","text":"<p>A single <code>APIExport</code> in kcp must only be processed by exactly 1 Sync Agent. There is currently no mechanism planned to subdivide an <code>APIExport</code> into shards, where multiple service clusters (and therefore multiple Sync Agents) could process each shard.</p> <p>Later the Sync Agent might be extended with Label Selectors, alternatively they might also \"claim\" any object by annotating it in the kcp workspace. These things are not yet worked out, so for now we have this 1:1 restriction.</p> <p>Sync Agents make use of leader election, so it's perfectly fine to have multiple Sync Agent replicas, as long as only one them is leader and actually doing work.</p>"},{"location":"#kcp-awareness","title":"kcp-awareness","text":"<p>controller-runtime can be used in a \"kcp-aware\" mode, where the cache, clients, mappers etc. are aware of the workspace information. This however is neither well tested upstream and the code would require shard-admin permissions to behave like this work regular kcp workspaces. The controller-runtime fork's kcp-awareness is really more geared towards working in virtual workspaces.</p> <p>Because of this the Sync Agent needs to get a kubeconfig to kcp that already points to the <code>APIExport</code>'s workspace (i.e. the <code>server</code> URL already contains a <code>/clusters/root:myorg</code> path). The basic controllers in the Sync Agent then treat this as a plain ol', regular Kubernetes cluster (no kcp-awareness).</p> <p>To this end, the Sync Agent will, upon startup, try to access the <code>cluster</code> object in the target workspace. This is to resolve the cluster name (e.g. <code>root:myorg</code>) into a logicalcluster name (e.g. <code>gibd3r1sh</code>). The Sync Agent has to know which logicalcluster the target workspace represents in order to query resources properly.</p> <p>Only the controllers that are later responsible for interacting with the virtual workspace are kcp-aware. They have to be in order to know what workspace a resource is living in.</p>"},{"location":"#publishedresources","title":"PublishedResources","text":"<p>A <code>PublishedResource</code> describes which CRD should be made available inside kcp. The CRD name can be projected (i.e. renamed), so a <code>kubermatic.k8c.io/v1 Cluster</code> can become a <code>cloud.examplecorp/v1 KubernetesCluster</code>.</p> <p>In addition to projecting (mapping) the GVK, the <code>PublishedResource</code> also contains optional naming rules, which influence how the local objects that the Sync Agent is creating are named.</p> <p>As a single Sync Agent serves a single service, the API group used in kcp is the same for all <code>PublishedResources</code>. It's the API group configured in the <code>APIExport</code> inside kcp (created in step 1 in the overview above).</p> <p>To prevent chaos, <code>PublishedResources</code> are immutable: handling the case that a PR first wants to publish <code>kubermatic.k8c.io/v1 Cluster</code> and then suddenly <code>kubermatic.k8c.io/v1 User</code> resources would mean to re-sync and cleanup everything in all affected kcp workspaces. The Sync Agent would need to be able to delete and recreate objects to follow this GVK change, which is a level of complexity we simply do not want to deal with at this point in time. Also, <code>APIResourceSchemas</code> are immutable themselves.</p> <p>More information is available in the Publishing Resources guide.</p>"},{"location":"#apiexports","title":"APIExports","text":"<p>An <code>APIExport</code> in kcp combines multiple <code>APIResourceSchemas</code> (ARS). Each ARS is created based on a <code>PublishedResource</code> in the service cluster.</p> <p>To prevent data loss, ARS are never removed from an <code>APIExport</code>. We simply do not have enough experience to really know what happens when an ARS would suddenly become unavailable. To prevent damage and confusion, the Sync Agent will only ever add new ARS to the one <code>APIExport</code> it manages.</p>"},{"location":"#controllers","title":"Controllers","text":"<p>The Sync Agent consists of a number of independent controllers.</p>"},{"location":"#apiexport","title":"apiexport","text":"<p>This controller aggregates the <code>PublishedResources</code> and manages a single <code>APIExport</code> in kcp.</p>"},{"location":"#apiresourceschema","title":"apiresourceschema","text":"<p>This controller takes <code>PublishedResources</code>, projects and converts them and creates <code>APIResourceSchemas</code> in kcp.</p>"},{"location":"#syncmanager","title":"syncmanager","text":"<p>This controller watches the <code>APIExport</code> and waits for the virtual workspace to become available. It also watches all <code>PublishedResources</code> (PRs) and reconciles when any of them is changed (they are immutable, but the controller is still reacting to any events on them).</p> <p>The controller will then setup a controller-runtime <code>Cluster</code> abstraction for the virtual workspace and then start many <code>sync</code> controllers (one for each <code>PublishedResource</code>). Whenever PRs change, the syncmanager will make sure that the correct set of <code>sync</code> controller is running.</p>"},{"location":"#sync","title":"sync","text":"<p>This is where the meat and potatoes happen. The sync controller is started for a single <code>PublishedResource</code> and is responsible for synchronizing all objects for that resource between the local service cluster and kcp.</p> <p>The <code>sync</code> controller was written to handle a single <code>PublishedResource</code> so that it does not have to deal with dynamically registering/stopping watches on its own. Instead the sync controller can be written as more or less \"normal\" controller-runtime controller.</p>"},{"location":"consuming-services/","title":"Consuming Services","text":"<p>This document describes how to use (consume) services offered by a Sync Agent.</p>"},{"location":"consuming-services/#background","title":"Background","text":"<p>A \"service\" defines a unique Kubernetes API Group and offers a number of resources (types) to use. A service could offer certificate management, databases, cloud infrastructure or any other set of Kubernetes resources.</p> <p>Services are provided by service owners, who run their own Kubernetes clusters and take care of the maintenance and scaling tasks for the workload provisioned by all users of the service(s) they offer.</p> <p>A Service provided by a Sync Agent should not be confused with a Kubernetes Service. Internally, a \"Sync Agent Service\" is ultimately translated into a kcp <code>APIExport</code> with a number of <code>APIResourceSchemas</code> (which are more or less equivalent to CRDs).</p>"},{"location":"consuming-services/#consuming-a-service","title":"Consuming a Service","text":"<p>To consume a service (or to make use of an <code>APIExport</code>) you have to create an <code>APIBinding</code> object in the kcp workspace where the service should be used. This section assumes that you are familiar with kcp on the command line and have the kcp kubectl plugin installed.</p> <p>First you need to get the kubeconfig for accessing your kcp workspaces. Once you have set your kubeconfig up, make sure you're in the correct namespace by using <code>kubectl ws &lt;path to your workspace&gt;</code>. Use <code>kubectl ws .</code> if you're unsure where you're at.</p> <p>To enable a Service, use <code>kcp bind apiexport</code> and specify the path to and name of the <code>APIExport</code>.</p> <pre><code># kubectl kcp bind apiexport &lt;path to APIExport&gt;:&lt;API Group of the Service&gt;\nkubectl kcp bind apiexport :root:my-org:my.fancy.api\n</code></pre> <p>Without the plugin, you can create an <code>APIBinding</code> manually, simply <code>kubectl apply</code> this:</p> <pre><code>apiVersion: apis.kcp.io/v1alpha1\nkind: APIBinding\nmetadata:\n  name: my.fancy.api\nspec:\n  reference:\n    export:\n      name: my.fancy.api\n      path: root:my-org\n</code></pre> <p>Shortly after, the new API will be available in the workspace. Check via <code>kubectl api-resources</code>. You can now create objects for types in that API group to your liking and they will be synced and processed behind the scenes.</p> <p>Note that a Service often has related resources, often Secrets and ConfigMaps. You must explicitly allow the Service to access these in your workspace and this means editing/patching the <code>APIBinding</code> object (the kcp kubectl plugin currently has no support for managing permission claims). For each of the claimed resources, you have to accept or reject them:</p> <pre><code>spec:\n  permissionClaims:\n    # Nearly all Sync Agents require access to namespaces, rejecting this will\n    # most likely break the Service, even more than rejecting any other claim.\n    - all: true\n      resources: namespaces\n      state: Accepted\n    - all: true\n      resources: secrets\n      state: Accepted # or Rejected\n</code></pre> <p>Rejecting a claim will severely impact a Service, if not even break it. Consult with the Service's documentation or the service owner if rejecting a claim is supported.</p> <p>When you change into (<code>kubctl ws \u2026</code>) a different workspace, kubectl will inform you if there are outstanding permission claims that you need to accept or reject.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#can-i-run-multiple-sync-agents-on-the-same-service-cluster","title":"Can I run multiple Sync Agents on the same service cluster?","text":"<p>Yes, absolutely, however you must configure them properly:</p> <p>A given <code>PublishedResource</code> must only ever be processed by a single Sync Agent Pod. The Helm chart configures leader-election by default, so you can scale up to have Pods on stand-by if needed.</p> <p>By default the Sync Agent will discover and process all <code>PublishedResources</code> in your cluster. Use the <code>--published-resource-selector</code> (<code>publishedResourceSelector</code> in the Helm values.yaml) to restrict an Agent to a subset of published resources.</p>"},{"location":"faq/#can-i-synchronize-multiple-kcp-setups-onto-the-same-service-cluster","title":"Can I synchronize multiple kcp setups onto the same service cluster?","text":"<p>Only if you have distinct API groups (and therefore also distinct <code>PublishedResources</code>) for them. You cannot currently publish the same API group onto multiple kcp setups. See issue #13 for more information.</p>"},{"location":"faq/#can-i-have-additional-resources-in-apiexports-unmanaged-by-the-sync-agent","title":"Can I have additional resources in APIExports, unmanaged by the Sync Agent?","text":"<p>Yes, you can. The agent will only ever change those resourceSchemas that match group/resource of the configured <code>PublishedResources</code>. So if you configure the agent to publish <code>cert-manager.io/Certificate</code>, this would \"claim\" all resource schemas ending in <code>.certificates.cert-manager.io</code>. When updating the <code>APIExport</code>, the agent will only touch schemas with this suffix and leave all others alone.</p> <p>This is also used when a <code>PublishedResource</code> is deleted: Since the <code>APIResourceSchema</code> remains in kcp, but is no longer configured in the agent, the agent will simply ignore the schema in the <code>APIExport</code>. This allows for async cleanup processes to happen before an admin ultimately removes the old schema from the <code>APIExport</code>.</p>"},{"location":"faq/#does-the-sync-agent-handle-permission-claims","title":"Does the Sync Agent handle permission claims?","text":"<p>Only those required for its own operation. If you configure a namespaced resource to sync, it will automatically add a claim for <code>namespaces</code> in kcp, plus it will add either <code>configmaps</code> or <code>secrets</code> if related resources are configured in a <code>PublishedResource</code>. But you cannot specify additional permissions claims.</p>"},{"location":"faq/#i-am-seeing-errors-in-the-agent-logs-whats-going-on","title":"I am seeing errors in the agent logs, what's going on?","text":"<p>Errors like</p> <p>reflector.go:561] k8s.io/client-go@v0.31.2/tools/cache/reflector.go:243: failed to list example.com/v1, Kind=Dummy: the server could not find the requested resource</p> <p>or</p> <p>reflector.go:158] \"Unhandled Error\" err=\"k8s.io/client-go@v0.31.2/tools/cache/reflector.go:243: Failed to watch kcp.example.com/v1, Kind=Dummy: failed to list kcp.example.com/v1, Kind=Dummy: the server could not find the requested resource\" logger=\"UnhandledError\"</p> <p>are typical when bootstrapping new APIExports in kcp. They are only cause for concern if they persist after configuring all PublishedResources.</p>"},{"location":"getting-started/","title":"Getting Started with the Sync Agent","text":"<p>All that is necessary to run the Sync Agent is a running Kubernetes cluster (for testing you can use kind) and a kcp installation.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A running Kubernetes cluster to run the Sync Agent in.</li> <li>A running kcp installation as the source of truth.</li> <li>A kubeconfig with admin or comparable permissions in a specific kcp workspace.</li> </ul>"},{"location":"getting-started/#apiexport-setup","title":"APIExport Setup","text":"<p>Before installing the Sync Agent it is necessary to create an <code>APIExport</code> on kcp. The <code>APIExport</code> should be empty, because it is updated later by the Sync Agent, but it defines the new API group we're introducing. An example file could look like this:</p> <pre><code>apiVersion: apis.kcp.io/v1alpha1\nkind: APIExport\nmetadata:\n  name: test.example.com\nspec: {}\n</code></pre> <p>Create a file with a similar content (you most likely want to change the name, as that is the API group under which your published resources will be made available) and create it in a kcp workspace of your choice:</p> <pre><code># use the kcp kubeconfig\n$ export KUBECONFIG=/path/to/kcp.kubeconfig\n\n# nativagate to the workspace where the APIExport should exist\n$ kubectl ws :workspace:you:want:to:create:it\n\n# create it\n$ kubectl create --filename apiexport.yaml\napiexport/test.example.com created\n</code></pre>"},{"location":"getting-started/#optional-create-initial-apibinding","title":"Optional: Create Initial APIBinding","text":"<p>To save resources, kcp doesn't start API endpoints for <code>APIExports</code> that are not in use (i.e. that don't have an active <code>APIBinding</code>). To avoid cryptic errors in the Sync Agent logs about resources not being found, you can create an initial <code>APIBinding</code> in the same (or another) workspace as your <code>APIExport</code>.</p> <p>It could look like this:</p> <pre><code>apiVersion: apis.kcp.io/v1alpha1\nkind: APIBinding\nmetadata:\n  name: test.example.com\nspec:\n  reference:\n    export:\n      name: test.example.com\n</code></pre> <p>While still being in your <code>:workspace:you:want:to:create:it</code> workspace, you could create the <code>APIBinding</code> like this:</p> <pre><code>$ kubectl create --filename apibinding.yaml\napibinding/test.example.com created\n</code></pre>"},{"location":"getting-started/#sync-agent-installation","title":"Sync Agent Installation","text":"<p>The Sync Agent can be installed into any namespace, but in our example we are going with <code>kcp-system</code>. It doesn't necessarily have to live in the same Kubernetes cluster where it is synchronizing data to, but that is the common setup. Ultimately the Sync Agent synchronizes data between two kube endpoints.</p> <p>Now that the <code>APIExport</code> is created, switch to the Kubernetes cluster from which you wish to publish resources. You will need to ensure that a kubeconfig with access to the kcp workspace that the <code>APIExport</code> has been created in is stored as a <code>Secret</code> on this cluster. Make sure that the kubeconfig points to the right workspace (not necessarily the <code>root</code> workspace).</p> <p>This can be done via a command like this:</p> <pre><code>$ kubectl create secret generic kcp-kubeconfig \\\n  --namespace kcp-system \\\n  --from-file \"kubeconfig=admin.kubeconfig\"\n</code></pre>"},{"location":"getting-started/#helm-chart-setup","title":"Helm Chart Setup","text":"<p>The Sync Agent is shipped as a Helm chart and to install it, the next step is preparing a <code>values.yaml</code> file for the Sync Agent Helm chart. We need to pass the target <code>APIExport</code>, a name for the Sync Agent itself and a reference to the kubeconfig secret we just created.</p> <pre><code># Required: the name of the APIExport in kcp that this Sync Agent is supposed to serve.\napiExportName: test.example.com\n\n# Required: This Agent's public name, used to signal ownership over locally synced objects.\n# This value must be a valid Kubernetes label value, see\n# https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set\n# for more information.\n# Changing this value after the fact will make the agent ignore previously created objects,\n# so beware and relabel if necessary.\nagentName: unique-test\n\n# Required: Name of the Kubernetes Secret that contains a \"kubeconfig\" key,\n# with the kubeconfig provided by kcp to access it.\nkcpKubeconfig: kcp-kubeconfig\n</code></pre> <p>Once this <code>values.yaml</code> file is prepared, install a recent development build of the Sync Agent:</p> <pre><code>helm repo add kcp https://kcp-dev.github.io/helm-charts\nhelm repo update\n\nhelm install kcp-api-syncagent kcp/api-syncagent \\\n  --values values.yaml \\\n  --namespace kcp-system\n</code></pre> <p>Two <code>kcp-api-syncagent</code> Pods should start in the <code>kcp-system</code> namespace. If they crash you will need to identify the reason from container logs. A possible issue is that the provided kubeconfig does not have permissions against the target kcp workspace.</p>"},{"location":"getting-started/#service-cluster-rbac","title":"Service Cluster RBAC","text":"<p>The Sync Agent usually requires additional RBAC on the service cluster to function properly. The Helm chart will automatically allow it to read CRDs, namespaces and Secrets, but depending on how you configure your PublishedResources, additional permissions need to be created.</p> <p>For example, if the Sync Agent is meant to create <code>Certificate</code> objects (defined by cert-manager), you would need to grant it permissions on those:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: 'api-syncagent:unique-test'\nrules:\n  - apiGroups:\n      - cert-manager.io\n    resources:\n      - certificates\n    verbs:\n      - get\n      - list\n      - watch\n      - create\n      - update\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: 'api-syncagent:unique-test'\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: 'api-syncagent:unique-test'\nsubjects:\n  - kind: ServiceAccount\n    name: 'kcp-api-syncagent'\n    namespace: kcp-system\n</code></pre> <p>NB: Even though the PublishedResources might only create/update Certificates in a single namespace, due to the inner workings of the Agent they will still be watched (cached) cluster-wide. So you can tighten permissions on <code>create</code>/<code>update</code> operations to certain namespaces, but <code>watch</code> permissions need to be granted cluster-wide.</p>"},{"location":"getting-started/#kcp-rbac","title":"kcp RBAC","text":"<p>The Helm chart is installed on the service cluster and so cannot provision the necessary RBAC for the Sync Agent within kcp. Usually whoever creates the <code>APIExport</code> is also responsible for creating the RBAC rules that grant the Agent access.</p> <p>The Sync Agent needs to</p> <ul> <li>access the workspace of its <code>APIExport</code>,</li> <li>get the <code>LogicalCluster</code>,</li> <li>manage its <code>APIExport</code>,</li> <li>manage <code>APIResourceSchemas</code> and</li> <li>access the virtual workspace for its <code>APIExport</code>.</li> </ul> <p>This can be achieved by applying RBAC like this in the workspace where the <code>APIExport</code> resides:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: api-syncagent-mango\nrules:\n  # get the LogicalCluster\n  - apiGroups:\n      - core.kcp.io\n    resources:\n      - logicalclusters\n    resourceNames:\n      - cluster\n    verbs:\n      - get\n  # manage its APIExport\n  - apiGroups:\n      - apis.kcp.io\n    resources:\n      - apiexports\n    resourceNames:\n      - test.example.com\n    verbs:\n      - get\n      - list\n      - watch\n      - patch\n      - update\n  # manage APIResourceSchemas\n  - apiGroups:\n      - apis.kcp.io\n    resources:\n      - apiresourceschemas\n    verbs:\n      - get\n      - list\n      - watch\n      - create\n  # access the virtual workspace\n  - apiGroups:\n      - apis.kcp.io\n    resources:\n      - apiexports/content\n    resourceNames:\n      - test.example.com\n    verbs:\n      - '*'\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: api-syncagent-mango:system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: api-syncagent-mango\nsubjects:\n  - kind: User\n    name: api-syncagent-mango\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: api-syncagent-mango:access\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:kcp:workspace:access\nsubjects:\n  - kind: User\n    name: api-syncagent-mango\n</code></pre>"},{"location":"getting-started/#publish-resources","title":"Publish Resources","text":"<p>Once the Sync Agent Pods are up and running, you should be able to follow the Publishing Resources guide.</p>"},{"location":"getting-started/#consume-service","title":"Consume Service","text":"<p>Once resources have been published through the Sync Agent, they can be consumed on the kcp side (i.e. objects on kcp will be synced back and forth with the service cluster). Follow the guide to consuming services.</p>"},{"location":"contributing/releasing/","title":"Release Process","text":"<p>The guide describes how to release a new version of the api-syncagent.</p>"},{"location":"contributing/releasing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Have all desired changes merged and/or cherrypicked into the appropriate    release branch.</li> </ol>"},{"location":"contributing/releasing/#minor-release","title":"Minor Release","text":"<p>Minor releases (0.x) are tagged directly on the <code>main</code> branch and the <code>v0.X.0</code> tag represents where the corresponding <code>release/v0.X</code> branch branches off.</p> <ol> <li>Checkout the desired <code>main</code> branch commit.</li> <li>Tag the main module: <code>git tag -m \"version 0.X\" v0.X.0</code></li> <li>Tag the SDK module: <code>git tag -m \"SDK version 0.X\" sdk/v0.X.0</code></li> <li>Push the tags: <code>git push upstream v0.X.0 sdk/v0.X.0</code></li> <li>Create the release branch: <code>git checkout -B release/v0.X</code></li> <li>Push the release branch: <code>git push -u upstream release/v0.X</code></li> </ol>"},{"location":"contributing/releasing/#patch-releases","title":"Patch Releases","text":"<p>Patch releases (v0.x.y) are tagged with in a release branch.</p> <ol> <li>Checkout the desired <code>release/v0.X</code> branch commit.</li> <li>Tag the main module: <code>git tag -m \"version 0.X.Y\" v0.X.Y</code></li> <li>Tag the SDK module: <code>git tag -m \"SDK version 0.X.Y\" sdk/v0.X.Y</code></li> <li>Push the tags: <code>git push upstream v0.X.Y sdk/v0.X.Y</code></li> </ol>"},{"location":"publish-resources/","title":"Publishing Resources","text":"<p>The guide describes the process of making a resource (usually defined by a CustomResourceDefinition) of one Kubernetes cluster (the \"service cluster\" or \"local cluster\") available for use in kcp. This involves setting up an <code>APIExport</code> and then installing the Sync Agent and defining <code>PublishedResources</code> in the local cluster.</p> <p>All of the documentation and API types are worded and named from the perspective of a service owner, the person(s) who own a service and want to make it available to consumers in kcp.</p>"},{"location":"publish-resources/#high-level-overview","title":"High-level Overview","text":"<p>A \"service\" comprises a set of resources within a single Kubernetes API group. It doesn't need to be all of the resources in that group, service owners are free and encouraged to only make a subset of resources (i.e. a subset of CRDs) available for use in kcp.</p> <p>For each of the CRDs on the service cluster that should be published, the service owner creates a <code>PublishedResource</code> object, which will contain both which CRD to publish, as well as numerous other important settings that influence the behaviour around handling the CRD.</p> <p>When publishing a resource (CRD), service owners can choose to restrict it to a subset of available versions and even change API group, versions and names in transit (for example published a v1 from the service cluster as v1beta1 within kcp). This process of changing the identity of a CRD is called \"projection\" in the agent.</p> <p>All published resources together form the APIExport. When a service is enabled in a workspace (i.e. it is bound to it), users can manage objects for the projected resources described by the published resources. These objects will be synced from the workspace onto the service cluster, where they are meant to be processed in whatever way the service owners desire. Any possible status information (in the <code>status</code> subresource) will in turn be synced back up into the workspace where the user can inspect it.</p> <p>Additionally, a published resource can describe additional so-called \"related resources\". These usually originate on the service cluster and could be for example connection detail secrets created by Crossplane, but could also originate in the user workspace and just be additional, auxiliary resources that need to be synced down to the service cluster.</p>"},{"location":"publish-resources/#publishedresource","title":"<code>PublishedResource</code>","text":"<p>In its simplest form (which is rarely practical) a <code>PublishedResource</code> looks like this:</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs # name can be freely chosen\nspec:\n  resource:\n    kind: Certificate\n    apiGroup: cert-manager.io\n    versions: [v1]\n</code></pre> <p>However, you will most likely apply more configuration and use features described below.</p> <p>You always have to select at least one version, and all selected versions must be marked as <code>served</code> on the service cluster. If the storage version is selected to be published, it stays the storage version in kcp. If no storage version is selected, the latest selected version becomes the storage version.</p> <p>For more information refer to the API lifecycle.</p>"},{"location":"publish-resources/#filtering","title":"Filtering","text":"<p>The Sync Agent can be instructed to only work on a subset of resources in kcp. This can be restricted by namespace and/or label selector.</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs # name can be freely chosen\nspec:\n  resource: ...\n  filter:\n    namespace: my-app\n    resource:\n      matchLabels:\n        foo: bar\n</code></pre> <p>The configuration above would mean the agent only synchronizes objects from <code>my-app</code> namespaces (in each of the kcp workspaces) that also have a <code>foo=bar</code> label on them.</p>"},{"location":"publish-resources/#schema","title":"Schema","text":"<p>Warning: The actual CRD schema is always copied verbatim. All projections, mutations etc. have to take into account that the resource contents must be expressible without changes to the schema, so you cannot define entirely new fields in an object that are not defined by the original CRD.</p>"},{"location":"publish-resources/#projection","title":"Projection","text":"<p>For stronger separation of concerns and to enable whitelabelling of services, the type meta for CRDs can be projected, i.e. changed between the local service cluster and kcp. You could for example rename <code>Certificate</code> from cert-manager to <code>Sertifikat</code> inside kcp.</p> <p>Note that the API group of all published resources is always changed to the one defined in the APIExport object (meaning 1 Sync Agent serves all the selected published resources under the same API group). That is why changing the API group cannot be configured in the projection.</p> <p>Besides renaming the Kind and Version, dependent fields like Plural, ShortNames and Categories can be adjusted to fit the desired naming scheme in kcp. The Plural name is computed automatically, but can be overridden. ShortNames and Categories are copied unless overwritten in the <code>PublishedResource</code>.</p> <p>It is also possible to change the scope of resources, i.e. turning a namespaced resource into a cluster-wide. This should be used carefully and might require extensive mutations.</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs # name can be freely chosen\nspec:\n  resource: ...\n  projection:\n    # all of these options are optional\n    kind: Sertifikat\n    plural: Sertifikater\n    shortNames: [serts]\n    versions:\n      # old version =&gt; new version;\n      # this must not map multiple versions to the same new version.\n      v1: v1beta1\n    # categories: [management]\n    # scope: Namespaced # change only when you know what you're doing\n</code></pre> <p>Consumers (end users) in kcp would then ultimately see projected names only. Note that GVK projection applies only to the synced object itself and has no effect on the contents of these objects. To change the contents, use external solutions like Crossplane to transform objects. To change the contents, use Mutations.</p>"},{"location":"publish-resources/#re-naming","title":"(Re-)Naming","text":"<p>Since the Sync Agent ingests resources from many different Kubernetes clusters (workspaces) and combines them onto a single cluster, resources have to be renamed to prevent collisions and also follow the conventions of whatever tooling ultimately processes the resources locally.</p> <p>This snippet shows the implicit default configuration:</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs # name can be freely chosen\nspec:\n  resource: ...\n  naming:\n    namespace: '{{ .ClusterName }}'\n    name: '{{ .Object.metadata.namespace | sha3short }}-{{ .Object.metadata.name | sha3short }}'\n</code></pre> <p>This configuration ensures that no collisions will happen: Each workspace in kcp will create a namespace on the local cluster, with a combination of namespace and name hashes used for the actual resource names.</p> <p>You can override the name or namespaces rules, or both. It is your responsibility to ensure no naming conflicts can happen on the service cluster, as the agent cannot determine this automatically.</p>"},{"location":"publish-resources/#templating","title":"Templating","text":"<p>In <code>spec.naming</code>, Go template expressions are used to construct the desired name of the object's copy. In the templates used here, the following data is injected by the agent:</p> <pre><code>type localObjectNamingContext struct {\n    // Object is the full remote object found in a kcp workspace.\n    Object map[string]any\n    // ClusterName is the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\").\n    ClusterName logicalcluster.Name\n    // ClusterPath is the workspace path (e.g. \"root:customer:projectx\").\n    ClusterPath logicalcluster.Path\n}\n</code></pre> <p>For more details about the templating, see the Templating documentation.</p>"},{"location":"publish-resources/#legacy-naming-rules","title":"Legacy Naming Rules","text":"<p>Go templates for naming rules have been added in v0.3 of the agent. Previous versions used a <code>$variable</code>-based approach, which since has been deprecated. You are encouraged to migrate your PublishedResources over to Go templates.</p> <p>The following table shows the available variables and their modern replacements:</p> Deprecated Variable Go Template Description <code>$remoteClusterName</code> <code>{{ .ClusterName }}</code> the workspace's cluster name (e.g. \"1084s8ceexsehjm2\") <code>$remoteNamespace</code> <code>{{ .Object.metadata.namespace }}</code> the original namespace used by the consumer inside the workspace <code>$remoteNamespaceHash</code> <code>{{ .Object.metadata.namespace \\| shortHash }}</code> first 20 hex characters of the SHA-1 hash of <code>$remoteNamespace</code> <code>$remoteName</code> <code>{{ .Object.metadata.name }}</code> the original name of the object inside the workspace (rarely used to construct local namespace names) <code>$remoteNameHash</code> <code>{{ .Object.metadata.name \\| shortHash }}</code> first 20 hex characters of the SHA-1 hash of <code>$remoteName</code> <p>Note that <code>ClusterPath</code> was never available in <code>$variable</code> form.</p> <p>Note also that the <code>shortHash</code> function exists only for backwards compatibility with the old <code>$variable</code> syntax. The new default is to use SHA-3 instead (via the <code>sha3short</code> function). When migrating from the old syntax, you can use the <code>shortHash</code> function to ensure new objects are placed in the old locations. New setups should however use explicitly named functions for hashing, like <code>sha3sum</code> or <code>sha3short</code>. <code>sha3short</code> takes an optional length parameter that defaults to 20.</p>"},{"location":"publish-resources/#mutation","title":"Mutation","text":"<p>Besides projecting the type meta, changes to object contents are also nearly always required. These can be configured in a number of way in the <code>PublishedResource</code>.</p> <p>Configuration happens <code>spec.mutation</code> and there are two fields:</p> <ul> <li><code>spec</code> contains the mutation rules when syncing the desired state (often in <code>spec</code>, but can also   be other top-level fields) from the remote side to the local side. Use this to apply defaulting,   normalising, and enforcing rules.</li> <li><code>status</code> contains the mutation rules when syncing the <code>status</code> subresource back from the local   cluster up into kcp. Use this to normalize names and values (e.g. if you rewrote   <code>.spec.secretName</code> from <code>\"foo\"</code> to <code>\"dfkbssbfh\"</code>, make sure the status does not \"leak\" this name   by accident).</li> </ul> <p>Mutation is always done as a series of steps. Each step does exactly one thing and only one must be configured per step.</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs # name can be freely chosen\nspec:\n  resource: ...\n  mutation:\n    spec:\n      # choose one per step\n      - regex: ...\n        template: ...\n        delete: ...\n</code></pre>"},{"location":"publish-resources/#regex","title":"Regex","text":"<pre><code>regex:\n  path: \"json.path[expression]\"\n  pattern: \"(.+)\"\n  replacement: \"foo-\\\\1\"\n</code></pre> <p>This mutation applies a regular expression to a single value inside the document. JSON path is the usual path, without a leading dot.</p>"},{"location":"publish-resources/#template","title":"Template","text":"<pre><code>template:\n  path: \"json.path[expression]\"\n  template: \"{{ .LocalObject.metadata.namespace }}\"\n</code></pre> <p>This mutation applies a Go template expression to a single value inside the document. JSON path is the usual path, without a leading dot.</p>"},{"location":"publish-resources/#delete","title":"Delete","text":"<pre><code>delete:\n  path: \"json.path[expression]\"\n</code></pre> <p>This mutation simply removes the value at the given path from the document. JSON path is the usual path, without a leading dot.</p>"},{"location":"publish-resources/#related-resources","title":"Related Resources","text":"<p>The processing of resources on the service cluster often leads to additional resources being created, like a <code>Secret</code> for each cert-manager <code>Certificate</code> or a connection detail secret created by Crossplane. These need to be made available to the user in their workspaces.</p> <p>Likewise it's possible for auxiliary resources having to be created by the user, for example when the user has to provide credentials.</p> <p>To handle these cases, a <code>PublishedResource</code> can define multiple \"related resources\". Each related resource represents usually one, but can be multiple objects to synchronize between user workspace and service cluster. While the main published resource sync is always workspace-&gt;service cluster, related resources can originate on either side and so either can work as the source of truth.</p> <p>At the moment, only <code>ConfigMaps</code> and <code>Secrets</code> are allowed related resource kinds.</p> <p>For each related resource, the Sync Agent needs to be told how to find the object on the origin side and where to create it on the destination side. There are multiple options that you can choose from.</p> <p>By default all related objects live in the same namespace as the primary object (their owner/parent). If the primary object is cluster scoped, admins must configure additional rules to specify what namespace the ConfigMap/Secret shall be read from and created in.</p> <p>Related resources are always optional. Even if references (see below) are used and their path expression points to a non-existing field in the primary object (e.g. <code>spec.secretName</code> is configured, but that field does not exist in Certificate object), this will simply be treated as \"not yet existing\" and not create an error.</p>"},{"location":"publish-resources/#references","title":"References","text":"<p>A reference is a JSONPath-like expression that are evaluated on both sides of the synchronization. You configure a single path expression (like <code>spec.secretName</code>) and the sync agent will evaluate it in the original primary object (in kcp) and again in the copied primary object (on the service cluster). Since the primary object has already been mutated, the <code>spec.secretName</code> is already rewritten/adjusted to work on the service cluster (for example it was changed from <code>my-secret</code> to <code>jk23h4wz47329rz2r72r92-secret</code> on the service cluster side). By doing it this way, admins only have to think about mutations and rewrites once (when configuring the primary object in the PublishedResource) and the path will yield 2 ready to use values (<code>my-secret</code> and the computed value).</p> <p>The value selected by the path expression must be a string (or number, but it will be coalesced into a string) and can then be further adjusted by applying a regular expression to it.</p> <p>References can only ever select one related object. Their upside is that they are simple to understand and easy to use, but require a \"link\" in the primary object that would point to the related object.</p> <p>Here's an example on how to use references to locate the related object.</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs\nspec:\n  resource:\n    kind: Certificate\n    apiGroup: cert-manager.io\n    versions: [v1]\n\n  naming:\n    # this is where our CA and Issuer live in this example\n    namespace: kube-system\n    # need to adjust it to prevent collisions (normally clustername is the namespace)\n    name: \"{{ .ClusterName }}-{{ .Object.metadata.namespace | sha3short }}-{{ .Object.metadata.name | sha3short }}\"\n\n  related:\n    - # unique name for this related resource. The name must be unique within\n      # one PublishedResource and is the key by which consumers (end users)\n      # can identify and consume the related resource. Common names are\n      # \"connection-details\" or \"credentials\".\n      identifier: tls-secret\n\n      # \"service\" or \"kcp\"\n      origin: service\n\n      # for now, only \"Secret\" and \"ConfigMap\" are supported;\n      # there is no GVK projection for related resources\n      kind: Secret\n\n      # configure where in the parent object we can find the child object\n      object:\n        # Object can use either reference, labelSelector or template. In this\n        # example we use references.\n        reference:\n          # This path is evaluated in both the local and remote objects, to figure out\n          # the local and remote names for the related object. This saves us from having\n          # to remember mutated fields before their mutation (similar to the last-known\n          # annotation).\n          path: spec.secretName\n\n        # namespace part is optional; if not configured,\n        # Sync Agent assumes the same namespace as the owning resource\n        # namespace:\n        #   reference:\n        #     path: spec.secretName\n        #     regex:\n        #       pattern: '...'\n        #       replacement: '...'\n</code></pre>"},{"location":"publish-resources/#templates","title":"Templates","text":"<p>Similar to references, Go templates can also be used to determine the names of related objects on both sides of the sync. In fact, templates can be thought of as more powerful references since they allow for minimal logic to be embedded in them. Templates also do not necessarily have to select a value from the object (like a reference does), but can use any kind of logic to determine the names.</p> <p>Like references, templates can also only be used to select a single object per related resource.</p> <p>A template gets the following data injected into it:</p> <pre><code>type localObjectNamingContext struct {\n    // Side is set to either one of the possible origin values to indicate for\n    // which cluster the template is currently being evaluated for.\n    Side syncagentv1alpha1.RelatedResourceOrigin\n    // Object is the primary object belonging to the related object. Since related\n    // object templates are evaluated twice (once for the origin side and once\n    // for the destination side), object is the primary object on the side the\n    // template is evaluated for.\n    Object map[string]any\n    // ClusterName is the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\")\n    // of the kcp workspace that the synchronization is currently processing. This\n    // value is set for both evaluations, regardless of side.\n    ClusterName logicalcluster.Name\n    // ClusterPath is the workspace path (e.g. \"root:customer:projectx\"). This\n    // value is set for both evaluations, regardless of side.\n    ClusterPath logicalcluster.Path\n}\n</code></pre> <p>In the simplest form, a template can replace a reference:</p> <ul> <li>reference: <code>.spec.secretName</code></li> <li>Go template: <code>{{ .Object.spec.secretName }}</code></li> </ul> <p>Just like with references, the configured template is evaluated twice, once for each side of the synchronization. You can use the <code>Side</code> variable to allow for fully customized names on each side:</p> <pre><code>spec:\n  ...\n  related:\n    - identifier: tls-secret\n      # ..omitting other fields..\n      object:\n        template:\n          template: `{{ if eq .Side \"kcp\" }}name-in-kcp{{ else }}name-on-service-cluster{{ end }}`\n</code></pre> <p>See Templating for more information on how to use templates in PublishedResources.</p>"},{"location":"publish-resources/#label-selectors","title":"Label Selectors","text":"<p>In some cases, the primary object does not have a link to its child/children objects. In these cases, a label selector can be used. This allows to configure the labels that any related object must have to be included.</p> <p>Notably, this allows for multiple objects that are synced for a single configured related resource. The sync agent will not prevent misconfigurations, so great care must be taken when configuring selectors to not accidentally include too many objects.</p> <p>Additionally, it is assumed that</p> <ul> <li>Primary objects synced from kcp to a service cluster will be renamed, to prevent naming collisions.</li> <li>The renamed objects on the service cluster might contain private, sensitive information that should   not be leaked into kcp workspaces.</li> <li>When there is no explicit name being requested (like by setting <code>spec.secretName</code>), it can be   assumed that the operator on the service cluster that is actually processing the primary object   will use the primary object's name (at least in parts) to construct the names of related objects,   for example a Certificate <code>yaddasupersecretyadda</code> might automatically get a Secret created named   <code>yaddasupersecretyadda-secret</code>.</li> </ul> <p>Since the name of the related object must not leak into a kcp workspace, admins who configure a label selector also always have to provide a naming scheme for the copies of the related objects on the destination side.</p> <p>Namespaces work the same as with references, i.e. by default the same namespace as the primary object is assumed. However you can actually also use label selectors to find the origin namespaces dynamically. So you can configure two label selectors, and then agent will first use the namespace selector to find all applicable namespaces, and then use the other label selector in each of the applicable namespaces to finally locate the related objects. How useful this is depends a lot on how peculiar the underlying operators on the service clusters are.</p> <p>Here is an example on how to use label selectors:</p> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs\nspec:\n  resource:\n    kind: Certificate\n    apiGroup: cert-manager.io\n    versions: [v1]\n\n  naming:\n    namespace: kube-system\n    name: \"{{ .ClusterName }}-{{ .Object.metadata.namespace | sha3short }}-{{ .Object.metadata.name | sha3short }}\"\n\n  related:\n    - identifier: tls-secrets\n\n      # \"service\" or \"kcp\"\n      origin: service\n\n      # for now, only \"Secret\" and \"ConfigMap\" are supported;\n      # there is no GVK projection for related resources\n      kind: Secret\n\n      # configure where in the parent object we can find the child object\n      object:\n        # A selector is a standard Kubernetes label selector, supporting\n        # matchLabels and matchExpressions.\n        selector:\n          matchLabels:\n            my-key: my-value\n            another: pair\n            # Within matchLabels, keys and values are treated as Go templates.\n            # In this example, since the Secret originates on the service cluster\n            # (see \"origin\" above), we use LocalObject to determine the value\n            # for the selector. In case the object was heavily mutated during the\n            # sync, this will give access to the mutated values on the service\n            # cluster side.\n            '{{ shasum \"test\" }}': '{{ .LocalObject.spec.username }}'\n\n          # You also need to provide rules on how objects found by this selector\n          # should be named on the destination side of the sync. You can choose\n          # to define a rewrite rule that keeps the original name from the origin\n          # side, but this may leak undesirable internals to the users.\n          # Rewrites are either using regular expressions or templated strings,\n          # never both.\n          # The rewrite config is applied to each individual found object.\n          rewrite:\n            regex:\n              pattern: \"foo-(.+)\"\n              replacement: \"bar-\\\\1\"\n\n            # or\n            template:\n              template: \"{{ .Value }}-foo\"\n\n        # Like with references, the namespace can (or must) be configured explicitly.\n        # You do not need to also use label selectors here, you can mix and match\n        # freely.\n        # namespace:\n        #   reference:\n        #     path: metadata.namespace\n        #     regex:\n        #       pattern: '...'\n        #       replacement: '...'\n</code></pre> <p>There are two possible usages of Go templates when using label selectors. See Templating for more information on how to use templates in PublishedResources in general.</p>"},{"location":"publish-resources/#selector-templates","title":"Selector Templates","text":"<p>Each template rendered as part of a <code>matchLabels</code> selector gets the following data injected:</p> <pre><code>type relatedObjectLabelContext struct {\n    // LocalObject is the primary object copy on the local side of the sync\n    // (i.e. on the service cluster).\n    LocalObject map[string]any\n    // RemoteObject is the primary object original, in kcp.\n    RemoteObject map[string]any\n    // ClusterName is the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\")\n    // of the kcp workspace that the synchronization is currently processing\n    // (where the remote object exists).\n    ClusterName logicalcluster.Name\n    // ClusterPath is the workspace path (e.g. \"root:customer:projectx\").\n    ClusterPath logicalcluster.Path\n}\n</code></pre> <p>Note that in contrast to the <code>template</code> way of selecting objects, the templates here in the label selector are only evaluated once, on the origin side of the sync. The names of the destination side are determined using the rewrite mechanism (which might also be a Go template, see next section).</p>"},{"location":"publish-resources/#rewrite-rules","title":"Rewrite Rules","text":"<p>Each found related object on the origin side needs to have its own name on the destination side. To map from the origin to the destination side, regular expressions (see example snippet) or Go templates can be used.</p> <p>If a template is configured, it is evaluated once for every found related object. The template gets the following data injected into it:</p> <pre><code>type relatedObjectLabelRewriteContext struct {\n    // Value is either the a found namespace name (when a label selector was\n    // used to select the source namespaces for related objects) or the name of\n    // a found object (when a label selector was used to find objects). In the\n    // former case, the template should return the new namespace to use on the\n    // destination side, in the latter case it should return the new object name\n    // to use on the destination side.\n    Value string\n    // When a rewrite is used to rewrite object names, RelatedObject is the\n    // original related object (found on the origin side). This enables you to\n    // ignore the given Value entirely and just select anything from the object\n    // itself.\n    // RelatedObject is nil when the rewrite is performed for a namespace.\n    RelatedObject map[string]any\n    // LocalObject is the primary object copy on the local side of the sync\n    // (i.e. on the service cluster).\n    LocalObject map[string]any\n    // RemoteObject is the primary object original, in kcp.\n    RemoteObject map[string]any\n    // ClusterName is the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\")\n    // of the kcp workspace that the synchronization is currently processing\n    // (where the remote object exists).\n    ClusterName logicalcluster.Name\n    // ClusterPath is the workspace path (e.g. \"root:customer:projectx\").\n    ClusterPath logicalcluster.Path\n}\n</code></pre> <p>Regarding <code>Value</code>: The agent allows to individually configure rules for finding object names and object namespaces. Often the namespace is not configured because the related objects live in the same namespace as their owning, primary object.</p> <p>When a label selector is configured to find namespaces, the rewrite template will be evaluated once for each found namespace. In this case the <code>.Value</code> is the name of the found namespace. Remember, the template's job is to map the found namespace to the new namespace on the destination side of the sync.</p> <p>Once the namespaces have been determined, the agent will look for matching objects in each namespace individually. For each namespace it will again follow the configured source, may it be a selector, template or reference. If again a label selector is used, it will be applied in each namespace and the configured rewrite rule will be evaluated once per found object. In this case, <code>.Value</code> is the name of found object.</p>"},{"location":"publish-resources/#examples","title":"Examples","text":""},{"location":"publish-resources/#provide-certificates","title":"Provide Certificates","text":"<p>This combination of <code>APIExport</code> and <code>PublishedResource</code> make cert-manager certificates available in kcp. The <code>APIExport</code> needs to be created in a workspace, most likely in an organization workspace. The <code>PublishedResource</code> is created wherever the Sync Agent and cert-manager are running.</p> <pre><code>apiVersion: apis.kcp.io/v1alpha1\nkind: APIExport\nmetadata:\n  name: certificates.example.corp\nspec: {}\n</code></pre> <pre><code>apiVersion: syncagent.kcp.io/v1alpha1\nkind: PublishedResource\nmetadata:\n  name: publish-certmanager-certs\nspec:\n  resource:\n    kind: Certificate\n    apiGroup: cert-manager.io\n    versions: [v1]\n\n  naming:\n    # this is where our CA and Issuer live in this example\n    namespace: kube-system\n    # need to adjust it to prevent collisions (normally clustername is the namespace)\n    name: \"{{ .ClusterName }}-{{ .Object.metadata.namespace | sha3short }}-{{ .Object.metadata.name | sha3short }}\"\n\n  related:\n    - origin: service # service or kcp\n      kind: Secret    # for now, only \"Secret\" and \"ConfigMap\" are supported;\n                      # there is no GVK projection for related resources\n\n      # configure where in the parent object we can find\n      # the name/namespace of the related resource (the child)\n      object:\n        # This template is evaluated in both the local and remote objects, to figure out\n        # the local and remote names for the related object. This saves us from having\n        # to remember mutated fields before their mutation (similar to the last-known\n        # annotation).\n        template:\n          template: '{{ .Object.spec.secretName }}'\n</code></pre>"},{"location":"publish-resources/api-lifecycle/","title":"API Lifecycle","text":"<p>In only the rarest of cases will the first version of a CRD be also its final version. Instead usually CRDs evolve over time and Kubernetes has strong, though sometimes hard to use, support for managing different versions of CRDs and their resources.</p> <p>To understand how CRDs work in the context of the Sync Agent, it's important to first get familiar with the regular Kubernetes behaviour regarding CRD versioning.</p>"},{"location":"publish-resources/api-lifecycle/#basics","title":"Basics","text":"<p>The Sync Agent will, whenever a published CRD changes (this can also happen when the projection rules inside a <code>PublishedResource</code> are updated), create a new <code>APIResourceSchema</code> (ARS) in kcp. The name and version of this ARS are based on a hash of the projected CRD. Undoing a change would make the agent re-use the previously created ARS (ARS are immutable).</p> <p>After every reconciliation, the list of latest resource schemas in the configured <code>APIExport</code> is updated. For this the agent will find all ARS that belong to it (based on an ownership label) and then merge them into the <code>APIExport</code>. Resource schemas for unknown group/resource combinations are left untouched, so admins are free to add additional resource schemas to an <code>APIExport</code>.</p> <p>This means that every change to a CRD on the service cluster is applied practically immediately in each workspace that consumes the <code>APIExport</code>. Administrators are wise to act carefully when working with their CRDs on their service cluster. Sometimes it can make sense to turn-off the agent before testing new CRDs, even though this will temporarily suspend the synchronization.</p>"},{"location":"publish-resources/api-lifecycle/#single-version-crds","title":"Single-Version CRDs","text":"<p>A very common scenario is to only ever have a single version inside each CRD and keeping this version perpetually backwards-compatible. As long as all consumers are aware that certain fields might not be set yet in older objects, this scheme works out generally fine.</p> <p>The agent will handle this scenario just fine by itself. Whenever a CRD is updated, it will reflect those changes back into a new <code>APIResourceSchema</code> and update the <code>APIExport</code>, making the changes immediately available to all consumers. Since the agent itself doesn't much care for the contents of objects, it itself is not affected by any structural changes in CRDs, as long as it is able to apply them on the underlying Kubernetes cluster.</p>"},{"location":"publish-resources/api-lifecycle/#multi-version-crds","title":"Multi-Version CRDs","text":"<p>Having multiple versions in a single CRD is immediately much more work, since in Kubernetes all versions of a CRD must be losslessly convertible to every other version. Without CEL expressions or a dedicated conversion webhook this is practically impossible to achieve.</p> <p>At the moment kcp does not support CEL-based conversions, and there is no support for configuring a conversion webhook inside the Sync Agent either. This is because such a webhook would need to run very close to the kcp shards and it's simply out of scope for such a component to be described and deployed by the Sync Agent, let alone a trust nightmare for the kcp operators who would have to run foreign webhooks on their cluster.</p> <p>Since both conversion mechanisms are not usable in the current state of kcp and the Sync Agent, having multiple versions in a CRD can be difficult to manage.</p> <p>Generally the Sync Agent itself does not care much about the schemas of each CRD version or the convertibility between them. The synchronization works by using unstructured clients to the storage versison of the CRD on both sides (in kcp and on the service cluster). Which version is the storage version is up to the CRD author.</p> <p>When publishing multiple versions of a CRD</p> <ul> <li>only those versions marked as <code>served</code> can be picked and</li> <li>if no <code>storage</code> version is picked, the latest (highest) version will be chosen automatically as   the storage version in kcp.</li> </ul>"},{"location":"publish-resources/technical-details/","title":"Technical Details","text":"<p>The following sections go into more details of the behind the scenes magic.</p>"},{"location":"publish-resources/technical-details/#synchronization","title":"Synchronization","text":"<p>Even though the whole configuration is written from the standpoint of the service owner, the actual synchronization logic considers the kcp side as the canonical source of truth. The Sync Agent continuously tries to make the local objects look like the ones in kcp, while pushing status updates back into kcp (if the given <code>PublishedResource</code> (i.e. CRD) has a <code>status</code> subresource enabled).</p>"},{"location":"publish-resources/technical-details/#local-remote-connection","title":"Local &lt;-&gt; Remote Connection","text":"<p>The Sync Agent tries to keep sync-related metadata on the service cluster, away from the consumers. This is both to prevent vandalism and to hide implementation details.</p> <p>To ensure stability against future changes, once the Sync Agent has determined how a local object should be named, it will remember this decision in the object's metadata. This is so that on future reconciliations, the (potentially costly, but probably not) renaming logic does not need to be applied again. This allows the Sync Agent to change defaults and also allows the service owner to make changes to the naming rules without breaking existing objects.</p> <p>Since we do not want to store metadata on the kcp side, we instead rely on label selectors on the local objects. Each object on the service cluster has a label for the remote cluster name, namespace and object name, and when trying to find the matching local object, the Sync Agent simply does a label-based search.</p> <p>There is currently no sync-related metadata available on source objects (in kcp workspaces), as this would either be annotations (untyped strings...) or require schema changes to allow additional fields in basically random CRDs.</p> <p>Note that fields like <code>generation</code> or <code>resourceVersion</code> are not relevant for any of the sync logic.</p>"},{"location":"publish-resources/technical-details/#reconcile-loop","title":"Reconcile Loop","text":"<p>The sync loop can be divided into 5 parts:</p> <ol> <li>find the local object</li> <li>handle deletion</li> <li>ensure the destination object exists</li> <li>ensure the destination object's content matches the source object</li> <li>synchronize related resources the same way (repeat 1-4 for each related resource)</li> </ol>"},{"location":"publish-resources/technical-details/#phase-1-find-the-local-object","title":"Phase 1: Find the Local Object","text":"<p>For this, as mentioned in the connection chapter above, the Sync Agent tries to follow label selectors on the service cluster. This helps prevent cluttering with consumer workspaces with sync metadata. If no object is found to match the labels, that's fine and the loop will continue with phase 2, in which a possible Conflict error (if labels broke) is handled gracefully.</p> <p>The remote object in the workspace becomes the <code>source object</code> and its local equivalent on the service cluster is called the <code>destination object</code>.</p>"},{"location":"publish-resources/technical-details/#phase-2-handle-deletion","title":"Phase 2: Handle Deletion","text":"<p>A finalizer is used in the kcp workspaces to prevent orphans in the service cluster side. This is the only real evidence in the kcp side that the Sync Agent is even doing things. When a remote (source) object is deleted, the corresponding local object is deleted as well. Once the local object is gone, the finalizer is removed from the source object.</p>"},{"location":"publish-resources/technical-details/#phase-3-ensure-object-existence","title":"Phase 3: Ensure Object Existence","text":"<p>We have a source object and now need to create the destination. This chart shows what's happening.</p> <pre><code>graph TB\n    A(source object):::state --&gt; B([cleanup if in deletion]):::step\n    B --&gt; C([ensure finalizer on source object]):::step\n    C --&gt; D{exists local object?}\n\n    D -- yes --&gt; I(\"continue with next phase\u2026\"):::state\n    D -- no --&gt; E([apply projection]):::step\n\n    subgraph \"ensure dest object exists\"\n    E --&gt; G([ensure resulting namespace exists]):::step\n    G --&gt; H([create local object]):::step\n    H --&gt; H_err{Errors?}\n    H_err -- Conflict --&gt; J([attempt to adopt existing object]):::step\n    end\n\n    H_err -- success --&gt; I\n    J --&gt; I\n\n    classDef step color:#77F\n    classDef state color:#F77</code></pre> <p>After we followed through with these steps, both the source and destination objects exists and we can continue with phase 4.</p> <p>Resource adoption happens when creation of the initial local object fails. This can happen when labels get mangled. If such a conflict happens, the Sync Agent will \"adopt\" the existing local object by adding / fixing the labels on it, so that for the next reconciliation it will be found and updated.</p>"},{"location":"publish-resources/technical-details/#phase-4-content-synchronization","title":"Phase 4: Content Synchronization","text":"<p>Content synchronization is rather simple, really.</p> <p>First the source \"spec\" is used to patch the local object. Note that this step is called \"spec\", but should actually be called \"all top-level elements besides <code>apiVersion</code>, <code>kind</code>, <code>status</code> and <code>metadata</code>, but still including some labels and annotations\"; so if you were to publish RBAC objects, the syncer would include <code>roleRef</code> field, for example).</p> <p>To allow proper patch generation, the last known state is kept on the local object, similar to how <code>kubectl</code> creates an annotation for it. This is required for the Sync Agent to properly detect changes made by mutation webhooks on the service cluster.</p> <p>If the published resource (CRD) has a <code>status</code> subresource enabled (not just a <code>status</code> field in its scheme, it must be a real subresource), then the Sync Agent will copy the status from the local object back up to the remote (source) object.</p>"},{"location":"publish-resources/technical-details/#phase-5-sync-related-resources","title":"Phase 5: Sync Related Resources","text":"<p>The same logic for synchronizing the main published resource applies to their related resources as well. The only difference is that the source side can be either remote (workspace) or local (service cluster).</p> <p>Since the Sync Agent tries its best to keep sync-related data out of kcp workspaces, the last known state for related resources is not kept together with the destination object in the kcp workspaces. Instead all known states (from the main object and all related resources) is kept in a single Secret on the service cluster side.</p>"},{"location":"publish-resources/templating/","title":"Templating","text":"<p><code>PublishedResources</code> allow to use Go templates in a number of places. A simple template could look like <code>{{ .Object.spec.secretName | sha3sum }}</code>.</p>"},{"location":"publish-resources/templating/#general-usage","title":"General Usage","text":"<p>Users are encouraged to get familiar with the Go documentation on templates.</p> <p>Specifically within the agent, the following rules apply when a template is evaluated:</p> <ul> <li>All templates must evaluate successfully. Any error will cancel the synchronization process for   that object, potentially leaving it in a half-finished overall state.</li> <li>Templates should not output random values, as those can lead to reconcile loops and higher load   on the service cluster.</li> <li>Any leading and trailing whitespace will be automatically trimmed from the template's output.</li> <li>All \"objects\" mentioned in this documentation refer technically to an <code>unstructured.Unstructured</code>   value's <code>.Object</code> field, i.e. the JSON-decoded representation of a Kubernetes object.</li> </ul>"},{"location":"publish-resources/templating/#functions","title":"Functions","text":"<p>Templates can make use of all functions provided by sprig/v3, for example <code>join</code> or <code>b64enc</code>. The agent then adds the following functions:</p> <ul> <li><code>sha3sum STRING</code>Returns the hex-encoded SHA3-256 hash (32 characters long).</li> <li><code>sha3short STRING [LENGTH=20]</code>Returns the first <code>LENGTH</code> characters of the hex-encoded SHA3-256 hash.</li> <li><code>shortHash STRING</code>Returns the first 20 characters of the hex-encoded SHA-1 hash.   This function is only available for backwards compatibility when migrating <code>$variable</code>-based   naming rules to use Go templates. New setups should not use this function, but one of the explicitly   named ones, like <code>sha256sum</code> or <code>sha3sum</code>.</li> </ul>"},{"location":"publish-resources/templating/#context","title":"Context","text":"<p>Depending on where a template is used, different data is available inside the template. The following is a summary of those different values:</p>"},{"location":"publish-resources/templating/#primary-object-naming-rules","title":"Primary Object Naming Rules","text":"<p>This is for templates used in <code>.spec.naming</code>:</p> Name Type Description <code>Object</code> <code>map[string]any</code> the full remote object found in a kcp workspace <code>ClusterName</code> <code>logicalcluster.Name</code> the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\") <code>ClusterPath</code> <code>logicalcluster.Path</code> the workspace path (e.g. \"root:customer:projectx\")"},{"location":"publish-resources/templating/#related-object-template-source","title":"Related Object Template Source","text":"<p>This is for templates used in <code>.spec.related[*].object.template</code> and <code>.spec.related[*].object.namespace.template</code>:</p> Name Type Description <code>Side</code> <code>string</code> set to either one of the possible origin values (<code>kcp</code> or <code>origin</code>) to indicate for which cluster the template is currently being evaluated for <code>Object</code> <code>map[string]any</code> the primary object belonging to the related object. Since related object templates are evaluated twice (once for the origin side and once for the destination side), object is the primary object on the side the template is evaluated for <code>ClusterName</code> <code>logicalcluster.Name</code> the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\") of the kcp workspace that the synchronization is currently processing; this value is set for both evaluations, regardless of side <code>ClusterPath</code> <code>logicalcluster.Path</code> the workspace path (e.g. \"root:customer:projectx\"); this value is set for both evaluations, regardless of side <p>These templates are evaluated once on each side of the synchronization.</p>"},{"location":"publish-resources/templating/#related-object-label-selectors","title":"Related Object Label Selectors","text":"<p>This is for templates used in <code>.spec.related[*].object.selector.matchLabels</code> and <code>.spec.related[*].object.namespace.selector.matchLabels</code>, both keys and values:</p> Name Type Description <code>LocalObject</code> <code>map[string]any</code> the primary object copy on the local side of the sync (i.e. on the service cluster) <code>RemoteObject</code> <code>map[string]any</code> the primary object original, in kcp <code>ClusterName</code> <code>logicalcluster.Name</code> the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\") of the kcp workspace that the synchronization is currently processing (where the remote object exists) <code>ClusterPath</code> <code>logicalcluster.Path</code> the workspace path (e.g. \"root:customer:projectx\") <p>If a template for a key evaluates to an empty string, the key-value combination will be omitted from the final selector. Empty values however are allowed.</p>"},{"location":"publish-resources/templating/#related-object-label-selector-rewrites","title":"Related Object Label Selector Rewrites","text":"<p>This is for templates used in <code>.spec.related[*].object.selector.rewrite.template</code> and <code>.spec.related[*].object.namespace.selector.rewrite.template</code>:</p> Name Type Description <code>Value</code> <code>string</code> Either the a found namespace name (when a label selector was used to select the source namespaces for related objects) or the name of a found object (when a label selector was used to find objects). In the former case, the template should return the new namespace to use on the destination side, in the latter case it should return the new object name to use on the destination side. <code>RelatedObject</code> <code>map[string]any</code> When a rewrite is used to rewrite object names, RelatedObject is the original related object (found on the origin side). This enables you to ignore the given Value entirely and just select anything from the object itself. RelatedObject is <code>nil</code> when the rewrite is performed for a namespace. <code>LocalObject</code> <code>map[string]any</code> the primary object copy on the local side of the sync (i.e. on the service cluster) <code>RemoteObject</code> <code>map[string]any</code> the primary object original, in kcp <code>ClusterName</code> <code>logicalcluster.Name</code> the internal cluster identifier (e.g. \"34hg2j4gh24jdfgf\") of the kcp workspace that the synchronization is currently processing (where the remote object exists) <code>ClusterPath</code> <code>logicalcluster.Path</code> the workspace path (e.g. \"root:customer:projectx\")"},{"location":"reference/","title":"Reference","text":"<p>This chapter provides automatically generated references for the APIs provided by the kcp Sync Agent.</p>"},{"location":"reference/crd/syncagent.kcp.io/publishedresources/","title":"PublishedResource","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#publishedresource-crd-schema-reference-group-syncagentkcpio","title":"PublishedResource CRD schema reference (group syncagent.kcp.io)","text":"PublishedResource describes how an API type (usually defined by a CRD) on the service cluster should be exposed in kcp workspaces. Besides controlling how namespaced and cluster-wide resources should be mapped, the GVK can also be transformed to provide a uniform, implementation-independent access to the APIs inside kcp.  Full name: publishedresources.syncagent.kcp.io Group: syncagent.kcp.io Singular name: publishedresource Plural name: publishedresources Scope: Cluster Versions: v1alpha1"},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>PublishedResourceSpec describes the desired resource publication from a service cluster to kcp.</p> boolean <p>EnableWorkspacePaths toggles whether the Sync Agent will not just store the kcp cluster name as a label on each locally synced object, but also the full workspace path. This is optional because it requires additional requests to kcp and should only be used if the workspace path is of interest on the service cluster side.</p> object <p>If specified, the filter will be applied to the resources in a workspace and allow restricting which of them will be handled by the Sync Agent.</p> object <p>When given, the namespace filter will be applied to a resource\u2019s namespace.</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> object <p>When given, the resource filter will be applied to a resource itself.</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> object <p>Mutation allows to configure \u201crewrite rules\u201d to modify the objects in both directions during the synchronization.</p> array object object string Required object string Required string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string object string Required string Required array object object string Required object string Required string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string object string Required string Required object <p>Naming can be used to control how the namespace and names for local objects are formed. If not specified, the Sync Agent will use defensive defaults to prevent naming collisions in the service cluster. When configuring this, great care must be taken to not allow for naming collisions to happen; keep in mind that the same name/namespace can exists in many different kcp workspaces.</p> string <p>The name field allows to control the name the local objects created by the Sync Agent. If left empty, \u201c$remoteNamespaceHash-$remoteNameHash\u201d is assumed. This guarantees unique names as long as the cluster name ($remoteClusterName) is used for the local namespace (the default unless configured otherwise). This is a string with placeholders. The following placeholders can be used:</p> <ul> <li>$remoteClusterName   \u2013 the kcp workspace\u2019s cluster name (e.g. \u201c1084s8ceexsehjm2\u201d)</li> <li>$remoteNamespace     \u2013 the original namespace used by the consumer inside the kcp                         workspace (if targetNamespace is left empty, it\u2019s equivalent                         to setting \u201c$remote_ns\u201d)</li> <li>$remoteNamespaceHash \u2013 first 20 hex characters of the SHA-1 hash of $remoteNamespace</li> <li>$remoteName          \u2013 the original name of the object inside the kcp workspace                         (rarely used to construct local namespace names)</li> <li>$remoteNameHash      \u2013 first 20 hex characters of the SHA-1 hash of $remoteName</li> </ul> string <p>For namespaced resources, the this field allows to control where the local objects will be created. If left empty, \u201c$remoteClusterName\u201d is assumed. This is a string with placeholders. The following placeholders can be used:</p> <ul> <li>$remoteClusterName   \u2013 the kcp workspace\u2019s cluster name (e.g. \u201c1084s8ceexsehjm2\u201d)</li> <li>$remoteNamespace     \u2013 the original namespace used by the consumer inside the kcp                         workspace (if targetNamespace is left empty, it\u2019s equivalent                         to setting \u201c$remote_ns\u201d)</li> <li>$remoteNamespaceHash \u2013 first 20 hex characters of the SHA-1 hash of $remoteNamespace</li> <li>$remoteName          \u2013 the original name of the object inside the kcp workspace                         (rarely used to construct local namespace names)</li> <li>$remoteNameHash      \u2013 first 20 hex characters of the SHA-1 hash of $remoteName</li> </ul> object <p>Projection is used to change the GVK of a published resource within kcp. This can be used to hide implementation details and provide a customized API experience to the user. All fields in the projection are optional. If a field is set, it will overwrite that field in the GVK. The namespaced field can be set to turn a cluster-wide resource namespaced or vice-versa.</p> array <p>Categories can be used to overwrite the original categories a resource was in. Set this to an empty list to remove all categories.</p> string string <p>The API group, for example \u201cmyservice.example.com\u201d. Leave empty to not modify the API group.</p> string <p>The resource Kind, for example \u201cDatabase\u201d. Setting this field will also overwrite the singular name by lowercasing the resource kind. In addition, if this is set, the plural name will also be updated by taking the lowercased kind name and appending an \u201cs\u201d. If this would yield an undesirable name, use the plural field to explicitly give the plural name.</p> string <p>When overwriting the Kind, it can be necessary to also override the plural name in case of more complex pluralization rules.</p> string <p>Whether or not the resource is namespaced.</p> array <p>ShortNames can be used to overwrite the original short names for a resource, usually when the Kind is remapped, new short names are also in order. Set this to an empty list to remove all short names.</p> string string <p>The API version, for example \u201cv1beta1\u201d. Leave empty to not modify the version.</p> <p>This field must not be set when multiple versions have been selected.</p> <p>Deprecated: Use .versions instead.</p> object <p>Versions allows to map API versions onto new values in kcp. Leave empty to not modify the versions.</p> array object string Required <p>Identifier is a unique name for this related resource. The name must be unique within one PublishedResource and is the key by which consumers (end users) can identify and consume the related resource. Common names are \u201cconnection-details\u201d or \u201ccredentials\u201d. The identifier must be an alphanumeric string.</p> string Required <p>ConfigMap or Secret</p> object <p>Mutation configures optional transformation rules for the related resource. Status mutations are only performed when the related resource originates in kcp.</p> array object object string Required object string Required string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string object string Required string Required array object object string Required object string Required string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string object string Required string Required object Required <p>Object describes how the related resource can be found on the origin side and where it is to supposed to be created on the destination side.</p> object <p>Namespace configures in what namespace the related object resides in. If not specified, the same namespace as the main object is assumed. If the main object is cluster-scoped, this field is required and an error will be raised during syncing if the field is not specified.</p> object <p>Reference points to a field inside the main object. This reference is evaluated on both source and destination sides to find the related object.</p> <p>Deprecated: Use Go templates instead.</p> string Required <p>Path is a simplified JSONPath expression like \u201cmetadata.name\u201d. A reference must always select at least something in the object, even if the value is discarded by the regular expression.</p> object <p>Regex is a Go regular expression that is optionally applied to the selected value from the path.</p> string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string <p>Replacement is the string that the matched pattern is replaced with. It can contain references to groups in the pattern by using \\N.</p> object <p>Selector is a label selector that is useful if no reference is in the main resource (i.e. if the related object links back to its parent, instead of the parent pointing to the related object).</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> object Required object <p>Regex is a Go regular expression that is optionally applied to the selected value from the path.</p> string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string <p>Replacement is the string that the matched pattern is replaced with. It can contain references to groups in the pattern by using \\N.</p> object <p>TemplateExpression is a Go templated string that can make use of variables to construct the resulting string.</p> string object <p>Template is a Go templated string that can make use of variables to construct the resulting string.</p> string object <p>Reference points to a field inside the main object. This reference is evaluated on both source and destination sides to find the related object.</p> <p>Deprecated: Use Go templates instead.</p> string Required <p>Path is a simplified JSONPath expression like \u201cmetadata.name\u201d. A reference must always select at least something in the object, even if the value is discarded by the regular expression.</p> object <p>Regex is a Go regular expression that is optionally applied to the selected value from the path.</p> string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string <p>Replacement is the string that the matched pattern is replaced with. It can contain references to groups in the pattern by using \\N.</p> object <p>Selector is a label selector that is useful if no reference is in the main resource (i.e. if the related object links back to its parent, instead of the parent pointing to the related object).</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> object Required object <p>Regex is a Go regular expression that is optionally applied to the selected value from the path.</p> string <p>Pattern can be left empty to simply replace the entire value with the replacement.</p> string <p>Replacement is the string that the matched pattern is replaced with. It can contain references to groups in the pattern by using \\N.</p> object <p>TemplateExpression is a Go templated string that can make use of variables to construct the resulting string.</p> string object <p>Template is a Go templated string that can make use of variables to construct the resulting string.</p> string string Required object Required <p>Describes the \u201csource\u201d Resource that exists on this, the service cluster, that should be exposed in kcp workspaces. All fields have to be specified.</p> string Required <p>The API group of a resource, for example \u201cstorage.initroid.com\u201d.</p> string Required <p>The resource Kind, for example \u201cDatabase\u201d.</p> string <p>The API version, for example \u201cv1beta1\u201d. Setting this field will only publish the given version, otherwise all versions for the group/kind will be published.</p> <p>Deprecated: Use .versions instead.</p> array <p>Versions allows to select a subset of versions to publish. Leave empty to publish all available versions.</p> string object <p>Status contains reconciliation information for the published resource.</p> string"},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.enableWorkspacePaths","title":".spec.enableWorkspacePaths","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter","title":".spec.filter","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace","title":".spec.filter.namespace","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions","title":".spec.filter.namespace.matchExpressions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions[*]","title":".spec.filter.namespace.matchExpressions[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions[*].key","title":".spec.filter.namespace.matchExpressions[*].key","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions[*].operator","title":".spec.filter.namespace.matchExpressions[*].operator","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions[*].values","title":".spec.filter.namespace.matchExpressions[*].values","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchExpressions[*].values[*]","title":".spec.filter.namespace.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.namespace.matchLabels","title":".spec.filter.namespace.matchLabels","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource","title":".spec.filter.resource","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions","title":".spec.filter.resource.matchExpressions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions[*]","title":".spec.filter.resource.matchExpressions[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions[*].key","title":".spec.filter.resource.matchExpressions[*].key","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions[*].operator","title":".spec.filter.resource.matchExpressions[*].operator","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions[*].values","title":".spec.filter.resource.matchExpressions[*].values","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchExpressions[*].values[*]","title":".spec.filter.resource.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.filter.resource.matchLabels","title":".spec.filter.resource.matchLabels","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation","title":".spec.mutation","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec","title":".spec.mutation.spec","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*]","title":".spec.mutation.spec[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].delete","title":".spec.mutation.spec[*].delete","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].delete.path","title":".spec.mutation.spec[*].delete.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].regex","title":".spec.mutation.spec[*].regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].regex.path","title":".spec.mutation.spec[*].regex.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].regex.pattern","title":".spec.mutation.spec[*].regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].regex.replacement","title":".spec.mutation.spec[*].regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].template","title":".spec.mutation.spec[*].template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].template.path","title":".spec.mutation.spec[*].template.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.spec[*].template.template","title":".spec.mutation.spec[*].template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status","title":".spec.mutation.status","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*]","title":".spec.mutation.status[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].delete","title":".spec.mutation.status[*].delete","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].delete.path","title":".spec.mutation.status[*].delete.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].regex","title":".spec.mutation.status[*].regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].regex.path","title":".spec.mutation.status[*].regex.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].regex.pattern","title":".spec.mutation.status[*].regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].regex.replacement","title":".spec.mutation.status[*].regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].template","title":".spec.mutation.status[*].template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].template.path","title":".spec.mutation.status[*].template.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.mutation.status[*].template.template","title":".spec.mutation.status[*].template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.naming","title":".spec.naming","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.naming.name","title":".spec.naming.name","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.naming.namespace","title":".spec.naming.namespace","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection","title":".spec.projection","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.categories","title":".spec.projection.categories","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.categories[*]","title":".spec.projection.categories[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.group","title":".spec.projection.group","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.kind","title":".spec.projection.kind","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.plural","title":".spec.projection.plural","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.scope","title":".spec.projection.scope","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.shortNames","title":".spec.projection.shortNames","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.shortNames[*]","title":".spec.projection.shortNames[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.version","title":".spec.projection.version","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.projection.versions","title":".spec.projection.versions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related","title":".spec.related","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*]","title":".spec.related[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].identifier","title":".spec.related[*].identifier","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].kind","title":".spec.related[*].kind","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation","title":".spec.related[*].mutation","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec","title":".spec.related[*].mutation.spec","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*]","title":".spec.related[*].mutation.spec[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].delete","title":".spec.related[*].mutation.spec[*].delete","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].delete.path","title":".spec.related[*].mutation.spec[*].delete.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].regex","title":".spec.related[*].mutation.spec[*].regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].regex.path","title":".spec.related[*].mutation.spec[*].regex.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].regex.pattern","title":".spec.related[*].mutation.spec[*].regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].regex.replacement","title":".spec.related[*].mutation.spec[*].regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].template","title":".spec.related[*].mutation.spec[*].template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].template.path","title":".spec.related[*].mutation.spec[*].template.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.spec[*].template.template","title":".spec.related[*].mutation.spec[*].template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status","title":".spec.related[*].mutation.status","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*]","title":".spec.related[*].mutation.status[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].delete","title":".spec.related[*].mutation.status[*].delete","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].delete.path","title":".spec.related[*].mutation.status[*].delete.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].regex","title":".spec.related[*].mutation.status[*].regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].regex.path","title":".spec.related[*].mutation.status[*].regex.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].regex.pattern","title":".spec.related[*].mutation.status[*].regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].regex.replacement","title":".spec.related[*].mutation.status[*].regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].template","title":".spec.related[*].mutation.status[*].template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].template.path","title":".spec.related[*].mutation.status[*].template.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].mutation.status[*].template.template","title":".spec.related[*].mutation.status[*].template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object","title":".spec.related[*].object","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace","title":".spec.related[*].object.namespace","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.reference","title":".spec.related[*].object.namespace.reference","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.reference.path","title":".spec.related[*].object.namespace.reference.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.reference.regex","title":".spec.related[*].object.namespace.reference.regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.reference.regex.pattern","title":".spec.related[*].object.namespace.reference.regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.reference.regex.replacement","title":".spec.related[*].object.namespace.reference.regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector","title":".spec.related[*].object.namespace.selector","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions","title":".spec.related[*].object.namespace.selector.matchExpressions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions[*]","title":".spec.related[*].object.namespace.selector.matchExpressions[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions[*].key","title":".spec.related[*].object.namespace.selector.matchExpressions[*].key","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions[*].operator","title":".spec.related[*].object.namespace.selector.matchExpressions[*].operator","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions[*].values","title":".spec.related[*].object.namespace.selector.matchExpressions[*].values","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchExpressions[*].values[*]","title":".spec.related[*].object.namespace.selector.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.matchLabels","title":".spec.related[*].object.namespace.selector.matchLabels","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite","title":".spec.related[*].object.namespace.selector.rewrite","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite.regex","title":".spec.related[*].object.namespace.selector.rewrite.regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite.regex.pattern","title":".spec.related[*].object.namespace.selector.rewrite.regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite.regex.replacement","title":".spec.related[*].object.namespace.selector.rewrite.regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite.template","title":".spec.related[*].object.namespace.selector.rewrite.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.selector.rewrite.template.template","title":".spec.related[*].object.namespace.selector.rewrite.template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.template","title":".spec.related[*].object.namespace.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.namespace.template.template","title":".spec.related[*].object.namespace.template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.reference","title":".spec.related[*].object.reference","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.reference.path","title":".spec.related[*].object.reference.path","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.reference.regex","title":".spec.related[*].object.reference.regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.reference.regex.pattern","title":".spec.related[*].object.reference.regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.reference.regex.replacement","title":".spec.related[*].object.reference.regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector","title":".spec.related[*].object.selector","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions","title":".spec.related[*].object.selector.matchExpressions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions[*]","title":".spec.related[*].object.selector.matchExpressions[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions[*].key","title":".spec.related[*].object.selector.matchExpressions[*].key","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions[*].operator","title":".spec.related[*].object.selector.matchExpressions[*].operator","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions[*].values","title":".spec.related[*].object.selector.matchExpressions[*].values","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchExpressions[*].values[*]","title":".spec.related[*].object.selector.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.matchLabels","title":".spec.related[*].object.selector.matchLabels","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite","title":".spec.related[*].object.selector.rewrite","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite.regex","title":".spec.related[*].object.selector.rewrite.regex","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite.regex.pattern","title":".spec.related[*].object.selector.rewrite.regex.pattern","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite.regex.replacement","title":".spec.related[*].object.selector.rewrite.regex.replacement","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite.template","title":".spec.related[*].object.selector.rewrite.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.selector.rewrite.template.template","title":".spec.related[*].object.selector.rewrite.template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.template","title":".spec.related[*].object.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].object.template.template","title":".spec.related[*].object.template.template","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.related[*].origin","title":".spec.related[*].origin","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource","title":".spec.resource","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource.apiGroup","title":".spec.resource.apiGroup","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource.kind","title":".spec.resource.kind","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource.version","title":".spec.resource.version","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource.versions","title":".spec.resource.versions","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.spec.resource.versions[*]","title":".spec.resource.versions[*]","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/syncagent.kcp.io/publishedresources/#v1alpha1-.status.resourceSchemaName","title":".status.resourceSchemaName","text":""}]}